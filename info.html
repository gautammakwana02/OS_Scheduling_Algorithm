<!DOCTYPE html>
<html lang="en">
<head>
    <title>WT_OS_innovative</title>
</head>
<body>
    <style>

    #header_title{
        background-color: rgb(71, 70, 70);
        margin: 0px;
        padding: 50px;
        border: 0cm;
        
    }
    
    
    a{
        color: white; 
        margin: 10px;
        padding: 10px;
        padding-left: 25px;
        padding-right: 25px;
        border-radius: 0px;
        text-decoration: none;      
        text-align: center;
        font-size: 25px;  
    
    
    }

    .h1_head{
        font-size: 60px;
        text-align:center;
        color: rgb(255, 255, 255);

    }

    #header{
        background-color: black;
        margin: 0px;
        padding: 20px;
        
        
    }

    #content{
        background-color: black;
        margin-bottom: 8px;  
        padding-right: 25px;      
    }

    
    #title{
       color: white ;    
       font-size: 30px;
       
    }

    #body{
       background-color: blue;
       
    }

 
    #bottom {
        background-color: white;
        font-size: 25px;
        border:15px solid yellowgreen;
        border-radius: 20px;
        margin: 5%;
        padding: 5%;

      }
      
    .hh1{
        
        background-color: yellowgreen;
        padding: 2%;
    }
    
    .p1{

        background-color:rgb(71, 70, 70);
        padding: 3%;
        font-size: 25px;
        color:white;
        margin: 0%;

    }
   
    #footer{

        background-color: black;
        padding: 4%;
        margin: 0%;

    } 
    
   .image{
       padding-left: 30%;
   }


   ::-webkit-scrollbar {
    width: 0%; 
  }

    </style>


<div id="header_title">
    <h1 class="h1_head" >Web Technology </h1>
    <h1 class="h1_head" >Innovative Assignment</h1>
    <! h1 OS Innovative /h1 >
</div>
 
<div id="header">
      
    <a href="#bottom">Project Details</a>
    <a href="./home.html" target="_blank">OS Simulator</a>
    <a href="#footer"> Founder <i> Info</i></a> 

</div>


    
    <div id="bottom">
        <h2>Project title : OS Simulator</h2>
        <h2>Project Defination : <br>Simulating Operating system concepts like Process scheduling and Disk Sheduling using HTML, CSS and Javascript.</h2>
    </div>     
    
  

<div>
     <h1 class="hh1">CPU Scheduling in Operating System</h1>
     <p class="p1">CPU scheduling is a process that allows one process to use the CPU while the execution of another process is on hold(in waiting state) due to unavailability of any resource like I/O etc, thereby making full use of CPU. The aim of CPU scheduling is to make the system efficient, fast, and fair.

        Whenever the CPU becomes idle, the operating system must select one of the processes in the ready queue to be executed. The selection process is carried out by the short-term scheduler (or CPU scheduler). The scheduler selects from among the processes in memory that are ready to execute and allocates the CPU to one of them.</p>
      <h1 class="hh1">CPU Scheduling: Dispatcher</h1>
       <p class="p1">Another component involved in the CPU scheduling function is the Dispatcher. The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler. This function involves:

        Switching context
        Switching to user mode
        Jumping to the proper location in the user program to restart that program from where it left last time.
        The dispatcher should be as fast as possible, given that it is invoked during every process switch. The time taken by the dispatcher to stop one process and start another process is known as the Dispatch Latency. Dispatch Latency can be explained using the below figure:</p> 
      
        <br><br>
        <img class="image" src="https://www.studytonight.com/operating-system/images/cpu-scheduling-1.png" alt="">
        <br><br>
      
     <h1 class="hh1">Types of CPU Scheduling</h1>
     <p class="p1">
      CPU scheduling decisions may take place under the following four circumstances:
 
      <br>When a process switches from the running state to the waiting state(for I/O request or invocation of wait for the termination of one of the child processes).
      <br>When a process switches from the running state to the ready state (for example, when an interrupt occurs). 
      <br>When a process switches from the waiting state to the ready state(for example, completion of I/O).
      <br>When a process terminates.
      <br>In circumstances 1 and 4, there is no choice in terms of scheduling. A new process(if one exists in the ready queue) must be selected for execution. There is a choice, however in circumstances 2 and 3.
      <br>When Scheduling takes place only under circumstances 1 and 4, we say the scheduling scheme is non-preemptive; otherwise, the scheduling scheme is preemptive.
     </p>
     <br><br>
     <p class="p1">
Non-Preemptive Scheduling<br><br>
Under non-preemptive scheduling, once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU either by terminating or by switching to the waiting state.
This scheduling method is used by the Microsoft Windows 3.1 and by the Apple Macintosh operating systems.

It is the only method that can be used on certain hardware platforms because It does not require the special hardware(for example a timer) needed for preemptive scheduling.

In non-preemptive scheduling, it does not interrupt a process running CPU in the middle of the execution. Instead, it waits till the process completes its CPU burst time, and then after that it can allocate the CPU to any other process.

Some Algorithms based on non-preemptive scheduling are: Shortest Job First (SJF basically non-preemptive) Scheduling and Priority (non- preemptive version) Scheduling, etc.
</p>
<br><br>
<img  class="image" src="https://s3.studytonight.com/tutorials/uploads/pictures/1604473391-71449.jpg" alt="">
<br> <br>

<p class="p1">
    Preemptive Scheduling<br><br>
    In this type of Scheduling, the tasks are usually assigned with priorities. At times it is necessary to run a certain task that has a higher priority before another task although it is running. Therefore, the running task is interrupted for some time and resumed later when the priority task has finished its execution.
    
    Thus this type of scheduling is used mainly when a process switches either from running state to ready state or from waiting state to ready state. The resources (that is CPU cycles) are mainly allocated to the process for a limited amount of time and then are taken away, and after that, the process is again placed back in the ready queue in the case if that process still has a CPU burst time remaining. That process stays in the ready queue until it gets the next chance to execute.
    
    Some Algorithms that are based on preemptive scheduling are Round Robin Scheduling (RR), Shortest Remaining Time First (SRTF), Priority (preemptive version) Scheduling, etc.    
</p>
<br><br>
<img  class="image" src="https://s3.studytonight.com/tutorials/uploads/pictures/1604475762-71449.png" alt="">
<br><br>


<h1 class="hh1">CPU Scheduling: Scheduling Criteria</h1>

<p class="p1">
There are many different criteria to check when considering the "best" scheduling algorithm, they are:

<br><br>CPU Utilization:<br>
To make out the best use of the CPU and not to waste any CPU cycle, the CPU would be working most of the time(Ideally 100% of the time). Considering a real system, CPU usage should range from 40% (lightly loaded) to 90% (heavily loaded.)

<br><br>Throughput:<br>
It is the total number of processes completed per unit of time or rather says the total amount of work done in a unit of time. This may range from 10/second to 1/hour depending on the specific processes.

<br><br>Turnaround Time:<br>
It is the amount of time taken to execute a particular process, i.e. The interval from the time of submission of the process to the time of completion of the process(Wall clock time).

<br><br>Waiting Time:<br>
The sum of the periods spent waiting in the ready queue amount of time a process has been waiting in the ready queue to acquire get control on the CPU.


<br><br>Load Average:<br>
It is the average number of processes residing in the ready queue waiting for their turn to get into the CPU.

<br><br>Response Time:<br>
Amount of time it takes from when a request was submitted until the first response is produced. Remember, it is the time till the first response and not the completion of process execution(final response).

In general CPU utilization and Throughput are maximized and other factors are reduced for proper optimization.

<br><br>Scheduling Algorithms:<br>
To decide which process to execute first and which process to execute last to achieve maximum CPU utilization, computer scientists have defined some algorithms, they are:
<ol class="p1">

<li>Shortest-Job-First(SJF) Scheduling</li> </li>

<li>Priority Scheduling</li>

<li>Round Robin(RR) Scheduling</li>

<li>Multilevel Queue Scheduling</li>

<li>Multilevel Feedback Queue Scheduling</li>

<li>Shortest Remaining Time First (SRTF)</li>

<li>Longest Remaining Time First (LRTF)</li>

<li>Highest Response Ratio Next (HRRN)</li>
</ol>
</p>





<h1 class="hh1">Disk Scheduling</h1>

<p class="p1">As we know, a process needs two type of time, CPU time and IO time. For I/O, it requests the Operating system to access the disk.

However, the operating system must be fare enough to satisfy each request and at the same time, operating system must maintain the efficiency and speed of process execution.

The technique that operating system uses to determine the request which is to be satisfied next is called disk scheduling.

Let's discuss some important terms related to disk scheduling.

<br>

<br><br>Seek Time:<br>
Seek time is the time taken in locating the disk arm to a specified track where the read/write request will be satisfied.

<br><br>Rotational Latency:<br>
It is the time taken by the desired sector to rotate itself to the position from where it can access the R/W heads.

<br><br>Transfer Time:<br>
It is the time taken to transfer the data.

<br><br>Disk Access Time:<br>
Disk access time is given as,<br>

Disk Access Time = Rotational Latency + Seek Time + Transfer Time

<br><br>Disk Response Time:<br>
It is the average of time spent by each request waiting for the IO operation.

<br><br>Purpose of Disk Scheduling:<br>
The main purpose of disk scheduling algorithm is to select a disk request from the queue of IO requests and decide the schedule when this request will be processed.

<br><br>Goal of Disk Scheduling Algorithm:<br>
- Fairness<br>
- High throughout<br>
- Minimal traveling head time<br>
- Disk Scheduling Algorithms<br>
The list of various disks scheduling algorithm is given below. Each algorithm is carrying some advantages and disadvantages. The limitation of each algorithm leads to the evolution of a new algorithm.

<ol class="p1">
<li>FCFS scheduling algorithm</li>
<li>SSTF (shortest seek time first) algorithm</li>
<li>SCAN scheduling</li>
<li>C-SCAN scheduling</li>
<li>LOOK Scheduling</li>
<li>C-LOOK scheduling</li>
</ol>
</p>
</div>

<footer id="footer">

    <a href="#">Founder Info :</a><br><br>
    <a href="#">Name : Gautam Makwana</a><br>
    <a href="#">Roll no. : 20BCE145</a><br>
    <a href="#">Batch : B3</a><br>
    <a href="#">&copy; | 2022 GM</a>


</footer>



</body> 

</body>
</html>